# Coherence

There are novel issues regarding memory: coherence. This is introduced by the use of shared memory.
Each processor have a copy of data in their memory. If someone modifies this data, it will become incoherent.

Consistency is a similar problem, related to possibly changing the semantics of my program because of incosistent
memory access given by non deterministic execution on CPUs. This is very strict and case pose a serious limit to
performance of these systems.

Synchronization refers to the fact that multiple threads can both read and write values: the order in which these actions
are performed have a relevance.

## Single CPU

In single CPU systems, coherence memory arise from the use of the cache. As soon as the CPU updates the value of A, there
is a coherence problem since the cache contains a value that's not the same in the memory. If an I/O device tries to read
the same value of A, there would be a problem since memory in not coherent.

## ...

## Keeping cache coherent

It's architect's joib to keep cache values coherent. When any processors ahve a miss cache, notify other processors.
The first approach to this problem is the **snoopy cache**.

The cache snoops transactions on the bus and checks that there are no writes to location that already missed.
The protocol works like:

- upon a write miss, the address is invalidated in other caches before a write is performed;

- upon a read miss, is a dirty copy is found in some cache, a writeback is performed before the memory is read.

### MSI protocol

The address of the cache line are divided in: index of the address, offset. The offset specifies the size of the line.
Memory is never accessed with a single machine word, instead it's accessed by lines which are multiple of machine word.

In a direct mapped cache, each address having the same offset bits, will make its way in the same line.

We need to add a few bits to distinguish between states: modified, shared, invalid.

These states are handled with a finite state machine. Starting from S, on a read miss (P1 gets line from memory), if any
processor read, this state is not modified.

If another processor tries to write the same address (single line), to reflect the change I should invalidate locally
my copy, so I go to the invalid state.

On the contrary, if it's me trying to write on the value, I'll go in the modified state. Now what happens if P1 reads
or write the value? Nothing, I stay on the modified state.

What happens if someone else writes? I go to the invalid state. Once there, If a processor tries to write on a line that's
invlaid for me. For the other processors to see the most recent data, It depends on the eager/lazy approach of processors.

When in M state, and a processor tries to read the value, I write it back to DRAM and go to the S state. If my first
action is a write, I enter the modified state.
